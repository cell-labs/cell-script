// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	// "strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return [1]byte{b}
}
func ByteDefault() Byte {
	return [1]byte{0}
}
func ByteFromSliceUnchecked(slice []byte) Byte {
	var b Byte
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[0:]
}
func ByteFromSlice(slice []byte, _compatible bool) (Byte, error) {
	if len(slice) != uint32(1) {
		return Byte{}, errors.New("TotalSizeNotMatch")
	}
	var b Byte
	b[0] = slice[0]
	return b, errors.None()
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Uint32Builder table {
	inner [4]Byte
}

type Uint32 table {
	inner []byte
}

func NewUint32Builder() Uint32Builder {
	return Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) Uint32Builder {
	s.inner[3] = v
	return s
}

func Uint32FromSliceUnchecked(slice []byte) Uint32 {
	return Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return Uint32{}, errors.New(errMsg)
	}
	return Uint32{inner: slice}, errors.None()
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	return t
}

type Uint64Builder table {
	inner [8]Byte
}

type Uint64 table {
	inner []byte
}

func NewUint64Builder() Uint64Builder {
	return Uint64Builder{inner: [8]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint64Builder) Build() Uint64 {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	var ret Uint64
	ret.inner = b.Bytes()
	return ret
}

func (s *Uint64Builder) Set(v [8]Byte) Uint64Builder {
	s.inner = v
	return s
}

func (s *Uint64Builder) Nth0(v Byte) Uint64Builder {
	s.inner[0] = v
	return s
}

func (s *Uint64Builder) Nth1(v Byte) Uint64Builder {
	s.inner[1] = v
	return s
}

func (s *Uint64Builder) Nth2(v Byte) Uint64Builder {
	s.inner[2] = v
	return s
}

func (s *Uint64Builder) Nth3(v Byte) Uint64Builder {
	s.inner[3] = v
	return s
}

func (s *Uint64Builder) Nth4(v Byte) Uint64Builder {
	s.inner[4] = v
	return s
}

func (s *Uint64Builder) Nth5(v Byte) Uint64Builder {
	s.inner[5] = v
	return s
}

func (s *Uint64Builder) Nth6(v Byte) Uint64Builder {
	s.inner[6] = v
	return s
}

func (s *Uint64Builder) Nth7(v Byte) Uint64Builder {
	s.inner[7] = v
	return s
}

func Uint64FromSliceUnchecked(slice []byte) Uint64 {
	return Uint64{inner: slice}
}
func (s *Uint64) AsSlice() []byte {
	return s.inner
}

func Uint64Default() Uint64 {
	return Uint64FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint64FromSlice(slice []byte, _compatible bool) (Uint64, error) {
	sliceLen := len(slice)
	if sliceLen != 8 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint64", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(8)}, " ")
		return Uint64{}, errors.New(errMsg)
	}
	return Uint64{inner: slice}, errors.None()
}

func (s *Uint64) RawData() []byte {
	return s.inner
}

func (s *Uint64) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint64) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint64) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint64) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint64) Nth4() Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint64) Nth5() Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint64) Nth6() Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint64) Nth7() Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint64) AsBuilder() Uint64Builder {
	t := NewUint64Builder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	t.Nth4(s.Nth4())
	t.Nth5(s.Nth5())
	t.Nth6(s.Nth6())
	t.Nth7(s.Nth7())
	return t
}

type Uint128Builder table {
	inner [16]Byte
}

type Uint128 table {
	inner []byte
}

func NewUint128Builder() Uint128Builder {
	return Uint128Builder{inner: [16]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint128Builder) Build() Uint128 {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	var ret Uint128
	ret.inner = b.Bytes()
	return ret
}

func (s *Uint128Builder) Set(v [16]Byte) Uint128Builder {
	s.inner = v
	return s
}

func (s *Uint128Builder) Nth0(v Byte) Uint128Builder {
	s.inner[0] = v
	return s
}

func (s *Uint128Builder) Nth1(v Byte) Uint128Builder {
	s.inner[1] = v
	return s
}

func (s *Uint128Builder) Nth2(v Byte) Uint128Builder {
	s.inner[2] = v
	return s
}

func (s *Uint128Builder) Nth3(v Byte) Uint128Builder {
	s.inner[3] = v
	return s
}

func (s *Uint128Builder) Nth4(v Byte) Uint128Builder {
	s.inner[4] = v
	return s
}

func (s *Uint128Builder) Nth5(v Byte) Uint128Builder {
	s.inner[5] = v
	return s
}

func (s *Uint128Builder) Nth6(v Byte) Uint128Builder {
	s.inner[6] = v
	return s
}

func (s *Uint128Builder) Nth7(v Byte) Uint128Builder {
	s.inner[7] = v
	return s
}

func (s *Uint128Builder) Nth8(v Byte) Uint128Builder {
	s.inner[8] = v
	return s
}

func (s *Uint128Builder) Nth9(v Byte) Uint128Builder {
	s.inner[9] = v
	return s
}

func (s *Uint128Builder) Nth10(v Byte) Uint128Builder {
	s.inner[10] = v
	return s
}

func (s *Uint128Builder) Nth11(v Byte) Uint128Builder {
	s.inner[11] = v
	return s
}

func (s *Uint128Builder) Nth12(v Byte) Uint128Builder {
	s.inner[12] = v
	return s
}

func (s *Uint128Builder) Nth13(v Byte) Uint128Builder {
	s.inner[13] = v
	return s
}

func (s *Uint128Builder) Nth14(v Byte) Uint128Builder {
	s.inner[14] = v
	return s
}

func (s *Uint128Builder) Nth15(v Byte) Uint128Builder {
	s.inner[15] = v
	return s
}

func Uint128FromSliceUnchecked(slice []byte) Uint128 {
	return Uint128{inner: slice}
}
func (s *Uint128) AsSlice() []byte {
	return s.inner
}

func Uint128Default() Uint128 {
	return Uint128FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint128FromSlice(slice []byte, _compatible bool) (Uint128, error) {
	sliceLen := len(slice)
	if sliceLen != 16 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint128", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(16)}, " ")
		return Uint128{}, errors.New(errMsg)
	}
	return Uint128{inner: slice}, errors.None()
}

func (s *Uint128) RawData() []byte {
	return s.inner
}

func (s *Uint128) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint128) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint128) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint128) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint128) Nth4() Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint128) Nth5() Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint128) Nth6() Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint128) Nth7() Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint128) Nth8() Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Uint128) Nth9() Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Uint128) Nth10() Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Uint128) Nth11() Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Uint128) Nth12() Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Uint128) Nth13() Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Uint128) Nth14() Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Uint128) Nth15() Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Uint128) AsBuilder() Uint128Builder {
	t := NewUint128Builder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	t.Nth4(s.Nth4())
	t.Nth5(s.Nth5())
	t.Nth6(s.Nth6())
	t.Nth7(s.Nth7())
	t.Nth8(s.Nth8())
	t.Nth9(s.Nth9())
	t.Nth10(s.Nth10())
	t.Nth11(s.Nth11())
	t.Nth12(s.Nth12())
	t.Nth13(s.Nth13())
	t.Nth14(s.Nth14())
	t.Nth15(s.Nth15())
	return t
}

type Byte32Builder table {
	inner [32]Byte
}

type Byte32 table {
	inner []byte
}

func NewByte32Builder() Byte32Builder {
	return Byte32Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Byte32Builder) Build() Byte32 {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	var ret Byte32
	ret.inner = b.Bytes()
	return ret
}

func (s *Byte32Builder) Set(v [32]Byte) Byte32Builder {
	s.inner = v
	return s
}

func (s *Byte32Builder) Nth0(v Byte) Byte32Builder {
	s.inner[0] = v
	return s
}

func (s *Byte32Builder) Nth1(v Byte) Byte32Builder {
	s.inner[1] = v
	return s
}

func (s *Byte32Builder) Nth2(v Byte) Byte32Builder {
	s.inner[2] = v
	return s
}

func (s *Byte32Builder) Nth3(v Byte) Byte32Builder {
	s.inner[3] = v
	return s
}

func (s *Byte32Builder) Nth4(v Byte) Byte32Builder {
	s.inner[4] = v
	return s
}

func (s *Byte32Builder) Nth5(v Byte) Byte32Builder {
	s.inner[5] = v
	return s
}

func (s *Byte32Builder) Nth6(v Byte) Byte32Builder {
	s.inner[6] = v
	return s
}

func (s *Byte32Builder) Nth7(v Byte) Byte32Builder {
	s.inner[7] = v
	return s
}

func (s *Byte32Builder) Nth8(v Byte) Byte32Builder {
	s.inner[8] = v
	return s
}

func (s *Byte32Builder) Nth9(v Byte) Byte32Builder {
	s.inner[9] = v
	return s
}

func (s *Byte32Builder) Nth10(v Byte) Byte32Builder {
	s.inner[10] = v
	return s
}

func (s *Byte32Builder) Nth11(v Byte) Byte32Builder {
	s.inner[11] = v
	return s
}

func (s *Byte32Builder) Nth12(v Byte) Byte32Builder {
	s.inner[12] = v
	return s
}

func (s *Byte32Builder) Nth13(v Byte) Byte32Builder {
	s.inner[13] = v
	return s
}

func (s *Byte32Builder) Nth14(v Byte) Byte32Builder {
	s.inner[14] = v
	return s
}

func (s *Byte32Builder) Nth15(v Byte) Byte32Builder {
	s.inner[15] = v
	return s
}

func (s *Byte32Builder) Nth16(v Byte) Byte32Builder {
	s.inner[16] = v
	return s
}

func (s *Byte32Builder) Nth17(v Byte) Byte32Builder {
	s.inner[17] = v
	return s
}

func (s *Byte32Builder) Nth18(v Byte) Byte32Builder {
	s.inner[18] = v
	return s
}

func (s *Byte32Builder) Nth19(v Byte) Byte32Builder {
	s.inner[19] = v
	return s
}

func (s *Byte32Builder) Nth20(v Byte) Byte32Builder {
	s.inner[20] = v
	return s
}

func (s *Byte32Builder) Nth21(v Byte) Byte32Builder {
	s.inner[21] = v
	return s
}

func (s *Byte32Builder) Nth22(v Byte) Byte32Builder {
	s.inner[22] = v
	return s
}

func (s *Byte32Builder) Nth23(v Byte) Byte32Builder {
	s.inner[23] = v
	return s
}

func (s *Byte32Builder) Nth24(v Byte) Byte32Builder {
	s.inner[24] = v
	return s
}

func (s *Byte32Builder) Nth25(v Byte) Byte32Builder {
	s.inner[25] = v
	return s
}

func (s *Byte32Builder) Nth26(v Byte) Byte32Builder {
	s.inner[26] = v
	return s
}

func (s *Byte32Builder) Nth27(v Byte) Byte32Builder {
	s.inner[27] = v
	return s
}

func (s *Byte32Builder) Nth28(v Byte) Byte32Builder {
	s.inner[28] = v
	return s
}

func (s *Byte32Builder) Nth29(v Byte) Byte32Builder {
	s.inner[29] = v
	return s
}

func (s *Byte32Builder) Nth30(v Byte) Byte32Builder {
	s.inner[30] = v
	return s
}

func (s *Byte32Builder) Nth31(v Byte) Byte32Builder {
	s.inner[31] = v
	return s
}

func Byte32FromSliceUnchecked(slice []byte) Byte32 {
	return Byte32{inner: slice}
}
func (s *Byte32) AsSlice() []byte {
	return s.inner
}

func Byte32Default() Byte32 {
	return Byte32FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Byte32FromSlice(slice []byte, _compatible bool) (Byte32, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return Byte32{}, errors.New(errMsg)
	}
	return Byte32{inner: slice}, errors.None()
}

func (s *Byte32) RawData() []byte {
	return s.inner
}

func (s *Byte32) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Byte32) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Byte32) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Byte32) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Byte32) Nth4() Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Byte32) Nth5() Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Byte32) Nth6() Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Byte32) Nth7() Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Byte32) Nth8() Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Byte32) Nth9() Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Byte32) Nth10() Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Byte32) Nth11() Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Byte32) Nth12() Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Byte32) Nth13() Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Byte32) Nth14() Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Byte32) Nth15() Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Byte32) Nth16() Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Byte32) Nth17() Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Byte32) Nth18() Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Byte32) Nth19() Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Byte32) Nth20() Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Byte32) Nth21() Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Byte32) Nth22() Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Byte32) Nth23() Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Byte32) Nth24() Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Byte32) Nth25() Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Byte32) Nth26() Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Byte32) Nth27() Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Byte32) Nth28() Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Byte32) Nth29() Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Byte32) Nth30() Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Byte32) Nth31() Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Byte32) AsBuilder() Byte32Builder {
	t := NewByte32Builder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	t.Nth4(s.Nth4())
	t.Nth5(s.Nth5())
	t.Nth6(s.Nth6())
	t.Nth7(s.Nth7())
	t.Nth8(s.Nth8())
	t.Nth9(s.Nth9())
	t.Nth10(s.Nth10())
	t.Nth11(s.Nth11())
	t.Nth12(s.Nth12())
	t.Nth13(s.Nth13())
	t.Nth14(s.Nth14())
	t.Nth15(s.Nth15())
	t.Nth16(s.Nth16())
	t.Nth17(s.Nth17())
	t.Nth18(s.Nth18())
	t.Nth19(s.Nth19())
	t.Nth20(s.Nth20())
	t.Nth21(s.Nth21())
	t.Nth22(s.Nth22())
	t.Nth23(s.Nth23())
	t.Nth24(s.Nth24())
	t.Nth25(s.Nth25())
	t.Nth26(s.Nth26())
	t.Nth27(s.Nth27())
	t.Nth28(s.Nth28())
	t.Nth29(s.Nth29())
	t.Nth30(s.Nth30())
	t.Nth31(s.Nth31())
	return t
}

type Uint256Builder table {
	inner [32]Byte
}

type Uint256 table {
	inner []byte
}

func NewUint256Builder() Uint256Builder {
	return Uint256Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint256Builder) Build() Uint256 {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	var ret Uint64
	ret.inner = b.Bytes()
	return ret
}

func (s *Uint256Builder) Set(v [32]Byte) Uint256Builder {
	s.inner = v
	return s
}

func (s *Uint256Builder) Nth0(v Byte) Uint256Builder {
	s.inner[0] = v
	return s
}

func (s *Uint256Builder) Nth1(v Byte) Uint256Builder {
	s.inner[1] = v
	return s
}

func (s *Uint256Builder) Nth2(v Byte) Uint256Builder {
	s.inner[2] = v
	return s
}

func (s *Uint256Builder) Nth3(v Byte) Uint256Builder {
	s.inner[3] = v
	return s
}

func (s *Uint256Builder) Nth4(v Byte) Uint256Builder {
	s.inner[4] = v
	return s
}

func (s *Uint256Builder) Nth5(v Byte) Uint256Builder {
	s.inner[5] = v
	return s
}

func (s *Uint256Builder) Nth6(v Byte) Uint256Builder {
	s.inner[6] = v
	return s
}

func (s *Uint256Builder) Nth7(v Byte) Uint256Builder {
	s.inner[7] = v
	return s
}

func (s *Uint256Builder) Nth8(v Byte) Uint256Builder {
	s.inner[8] = v
	return s
}

func (s *Uint256Builder) Nth9(v Byte) Uint256Builder {
	s.inner[9] = v
	return s
}

func (s *Uint256Builder) Nth10(v Byte) Uint256Builder {
	s.inner[10] = v
	return s
}

func (s *Uint256Builder) Nth11(v Byte) Uint256Builder {
	s.inner[11] = v
	return s
}

func (s *Uint256Builder) Nth12(v Byte) Uint256Builder {
	s.inner[12] = v
	return s
}

func (s *Uint256Builder) Nth13(v Byte) Uint256Builder {
	s.inner[13] = v
	return s
}

func (s *Uint256Builder) Nth14(v Byte) Uint256Builder {
	s.inner[14] = v
	return s
}

func (s *Uint256Builder) Nth15(v Byte) Uint256Builder {
	s.inner[15] = v
	return s
}

func (s *Uint256Builder) Nth16(v Byte) Uint256Builder {
	s.inner[16] = v
	return s
}

func (s *Uint256Builder) Nth17(v Byte) Uint256Builder {
	s.inner[17] = v
	return s
}

func (s *Uint256Builder) Nth18(v Byte) Uint256Builder {
	s.inner[18] = v
	return s
}

func (s *Uint256Builder) Nth19(v Byte) Uint256Builder {
	s.inner[19] = v
	return s
}

func (s *Uint256Builder) Nth20(v Byte) Uint256Builder {
	s.inner[20] = v
	return s
}

func (s *Uint256Builder) Nth21(v Byte) Uint256Builder {
	s.inner[21] = v
	return s
}

func (s *Uint256Builder) Nth22(v Byte) Uint256Builder {
	s.inner[22] = v
	return s
}

func (s *Uint256Builder) Nth23(v Byte) Uint256Builder {
	s.inner[23] = v
	return s
}

func (s *Uint256Builder) Nth24(v Byte) Uint256Builder {
	s.inner[24] = v
	return s
}

func (s *Uint256Builder) Nth25(v Byte) Uint256Builder {
	s.inner[25] = v
	return s
}

func (s *Uint256Builder) Nth26(v Byte) Uint256Builder {
	s.inner[26] = v
	return s
}

func (s *Uint256Builder) Nth27(v Byte) Uint256Builder {
	s.inner[27] = v
	return s
}

func (s *Uint256Builder) Nth28(v Byte) Uint256Builder {
	s.inner[28] = v
	return s
}

func (s *Uint256Builder) Nth29(v Byte) Uint256Builder {
	s.inner[29] = v
	return s
}

func (s *Uint256Builder) Nth30(v Byte) Uint256Builder {
	s.inner[30] = v
	return s
}

func (s *Uint256Builder) Nth31(v Byte) Uint256Builder {
	s.inner[31] = v
	return s
}

func Uint256FromSliceUnchecked(slice []byte) Uint256 {
	return Uint256{inner: slice}
}
func (s *Uint256) AsSlice() []byte {
	return s.inner
}

func Uint256Default() Uint256 {
	return Uint256FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint256FromSlice(slice []byte, _compatible bool) (Uint256, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint256", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return Uint256{}, errors.New(errMsg)
	}
	return Uint256{inner: slice}, errors.None()
}

func (s *Uint256) RawData() []byte {
	return s.inner
}

func (s *Uint256) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint256) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint256) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint256) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint256) Nth4() Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint256) Nth5() Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint256) Nth6() Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint256) Nth7() Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint256) Nth8() Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Uint256) Nth9() Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Uint256) Nth10() Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Uint256) Nth11() Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Uint256) Nth12() Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Uint256) Nth13() Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Uint256) Nth14() Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Uint256) Nth15() Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Uint256) Nth16() Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Uint256) Nth17() Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Uint256) Nth18() Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Uint256) Nth19() Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Uint256) Nth20() Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Uint256) Nth21() Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Uint256) Nth22() Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Uint256) Nth23() Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Uint256) Nth24() Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Uint256) Nth25() Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Uint256) Nth26() Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Uint256) Nth27() Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Uint256) Nth28() Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Uint256) Nth29() Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Uint256) Nth30() Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Uint256) Nth31() Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Uint256) AsBuilder() Uint256Builder {
	t := NewUint256Builder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	t.Nth4(s.Nth4())
	t.Nth5(s.Nth5())
	t.Nth6(s.Nth6())
	t.Nth7(s.Nth7())
	t.Nth8(s.Nth8())
	t.Nth9(s.Nth9())
	t.Nth10(s.Nth10())
	t.Nth11(s.Nth11())
	t.Nth12(s.Nth12())
	t.Nth13(s.Nth13())
	t.Nth14(s.Nth14())
	t.Nth15(s.Nth15())
	t.Nth16(s.Nth16())
	t.Nth17(s.Nth17())
	t.Nth18(s.Nth18())
	t.Nth19(s.Nth19())
	t.Nth20(s.Nth20())
	t.Nth21(s.Nth21())
	t.Nth22(s.Nth22())
	t.Nth23(s.Nth23())
	t.Nth24(s.Nth24())
	t.Nth25(s.Nth25())
	t.Nth26(s.Nth26())
	t.Nth27(s.Nth27())
	t.Nth28(s.Nth28())
	t.Nth29(s.Nth29())
	t.Nth30(s.Nth30())
	t.Nth31(s.Nth31())
	return t
}

type BytesBuilder table {
	inner []Byte
}

type Bytes table {
	inner []byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	var b bytes.Buffer

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	var sb Bytes
	sb.inner = b.Bytes()
	return sb
}

func (s *BytesBuilder) Set(v []Byte) BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *BytesBuilder) Replace(index uint64, v Byte) Byte {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return Byte{}
}

func NewBytesBuilder() BytesBuilder {
	return BytesBuilder{inner: []Byte{}}
}

func BytesFromSliceUnchecked(slice []byte) Bytes {
	return Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int64(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return Bytes{}, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int64(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(HeaderSizeUint))}, " ")
			return Bytes{}, errors.New(errMsg)
		}
		return Bytes{inner: slice}, errors.None()
	}
	totalSize := int64(HeaderSizeUint) + int64(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return Bytes{}, errors.New(errMsg)
	}
	return Bytes{inner: slice}, errors.None()
}

func (s *Bytes) TotalSize() uint64 {
	return uint64(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint64 {
	number := uint64(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint64 {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if Byte is empty, index is out of bounds
func (s *Bytes) Get(index uint64) Byte {
	var re *Byte
	if index < s.Len() {
		start := uint64(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type BytesOptBuilder table {
	isNone bool
	inner  Bytes
}

type BytesOpt table {
	inner []byte
}

func NewBytesOptBuilder() BytesOptBuilder {
	return BytesOptBuilder{isNone: true, inner: BytesDefault()}
}
func (s *BytesOptBuilder) Set(v Bytes) BytesOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *BytesOptBuilder) Build() BytesOpt {
	var ret BytesOpt
	if s.isNone {
		ret = BytesOpt{ inner: []byte{} }
	} else {
		ret = BytesOpt{inner: s.inner.AsSlice()}
	}
	return ret
}

func BytesOptFromSliceUnchecked(slice []byte) BytesOpt {
	return BytesOpt{inner: slice}
}
func (s *BytesOpt) AsSlice() []byte {
	return s.inner
}

func BytesOptDefault() BytesOpt {
	return BytesOptFromSliceUnchecked([]byte{})
}

func BytesOptFromSlice(slice []byte, compatible bool) (BytesOpt, error) {
	if len(slice) == 0 {
		return BytesOpt{inner: slice}, errors.None()
	}

	var ret BytesOpt
	_, err := BytesFromSlice(slice, compatible)
	if err.NotNone() {
		return ret, err
	}
	return BytesOpt{inner: slice}, errors.None()
}

func (s *BytesOpt) IntoBytes() (Bytes, error) {
	if s.IsNone() {
		return Bytes{}, errors.New("No data")
	}
	return BytesFromSliceUnchecked(s.AsSlice()), errors.None()
}
func (s *BytesOpt) IsSome() bool {
	return len(s.inner) != 0
}
func (s *BytesOpt) IsNone() bool {
	return len(s.inner) == 0
}
func (s *BytesOpt) AsBuilder() BytesOptBuilder {
	var ret = NewBytesOptBuilder()
	if s.IsSome() {
		ret.Set(BytesFromSliceUnchecked(s.AsSlice()))
	}
	return ret
}

type BytesVecBuilder table {
	inner []Bytes
}

type BytesVec table {
	inner []byte
}

func (s *BytesVecBuilder) Build() BytesVec {
	itemCount := len(s.inner)

	var b bytes.Buffer

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return BytesVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return BytesVec{inner: b.Bytes()}
}

func (s *BytesVecBuilder) Set(v []Bytes) BytesVecBuilder {
	s.inner = v
	return s
}
func (s *BytesVecBuilder) Push(v Bytes) BytesVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesVecBuilder) Extend(iter []Bytes) BytesVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *BytesVecBuilder) Replace(index uint64, v Bytes) Bytes {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return Bytes{}
}

func NewBytesVecBuilder() BytesVecBuilder {
	return BytesVecBuilder{inner: []Bytes{}}
}

func BytesVecFromSliceUnchecked(slice []byte) BytesVec {
	return BytesVec{inner: slice}
}
func (s *BytesVec) AsSlice() []byte {
	return s.inner
}

func BytesVecDefault() BytesVec {
	return BytesVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func BytesVecFromSlice(slice []byte, compatible bool) (BytesVec, error) {
	sliceLen := len(slice)
	var bv BytesVec
	err := errors.None()

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return bv, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return bv, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return BytesVec{inner: slice}, err
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return bv, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return bv, errors.New(errMsg)
	}

	if sliceLen < int64(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
		return bv, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int64(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec"}, " ")
			return bv, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, e := BytesFromSlice(slice[start:end], compatible)

			if e.NotNone() {
				return bv, e
			}
		}
	}

	return BytesVec{inner: slice}, err
}

func (s *BytesVec) TotalSize() uint64 {
	return uint64(unpackNumber(s.inner))
}
func (s *BytesVec) ItemCount() uint64 {
	var number uint64 = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *BytesVec) Len() uint64 {
	return s.ItemCount()
}
func (s *BytesVec) IsEmpty() bool {
	return s.Len() == 0
}

// if Bytes is empty, index is out of bounds
func (s *BytesVec) Get(index uint64) Bytes {
	var b Bytes
	if index < s.Len() {
		start_index := uint64(HeaderSizeUint)  (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint64(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *BytesVec) AsBuilder() BytesVecBuilder {
	size := s.ItemCount()
	t := NewBytesVecBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type Byte32VecBuilder table {
	inner []Byte32
}

type Byte32Vec table {
	inner []byte
}

func (s *Byte32VecBuilder) Build() Byte32Vec {
	size := packNumber(Number(len(s.inner)))

	var b bytes.Buffer

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Byte32Vec{inner: b.Bytes()}

	return sb
}

func (s *Byte32VecBuilder) Set(v []Byte32) Byte32VecBuilder {
	s.inner = v
	return s
}
func (s *Byte32VecBuilder) Push(v Byte32) Byte32VecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *Byte32VecBuilder) Extend(iter []Byte32) Byte32VecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *Byte32VecBuilder) Replace(index uint64, v Byte32) Byte32 {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return Byte32{}
}

func NewByte32VecBuilder() Byte32VecBuilder {
	return Byte32VecBuilder{inner: []Byte32{}}
}

func Byte32VecFromSliceUnchecked(slice []byte) Byte32Vec {
	return Byte32Vec{inner: slice}
}
func (s *Byte32Vec) AsSlice() []byte {
	return s.inner
}

func Byte32VecDefault() Byte32Vec {
	return Byte32VecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Byte32VecFromSlice(slice []byte, _compatible bool) (Byte32Vec, error) {
	sliceLen := len(slice)
	if sliceLen < int64(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Byte32Vec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return Byte32Vec{}, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int64(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32Vec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(HeaderSizeUint))}, " ")
			return Byte32Vec{}, errors.New(errMsg)
		}
		return Byte32Vec{inner: slice}, errors.None()
	}
	totalSize := int64(HeaderSizeUint) + int64(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32Vec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return Byte32Vec{}, errors.New(errMsg)
	}
	return Byte32Vec{inner: slice}, errors.None()
}

func (s *Byte32Vec) TotalSize() uint64 {
	return uint64(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *Byte32Vec) ItemCount() uint64 {
	number := uint64(unpackNumber(s.inner))
	return number
}
func (s *Byte32Vec) Len() uint64 {
	return s.ItemCount()
}
func (s *Byte32Vec) IsEmpty() bool {
	return s.Len() == 0
}

// if Byte32 is empty, index is out of bounds
func (s *Byte32Vec) Get(index uint64) Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint64(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Byte32Vec) AsBuilder() Byte32VecBuilder {
	size := s.ItemCount()
	t := NewByte32VecBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type Script table {
	inner []byte
}

type ScriptOptBuilder table {
	isNone bool
	inner  Script
}

type ScriptOpt table {
	inner []byte
}

func NewScriptOptBuilder() ScriptOptBuilder {
	return ScriptOptBuilder{isNone: true, inner: ScriptDefault()}
}
func (s *ScriptOptBuilder) Set(v Script) ScriptOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *ScriptOptBuilder) Build() ScriptOpt {
	var ret ScriptOpt
	if s.isNone {
		ret = ScriptOpt{inner: []byte{}}
	} else {
		ret = ScriptOpt{inner: s.inner.AsSlice()}
	}
	return ret
}

func ScriptOptFromSliceUnchecked(slice []byte) ScriptOpt {
	return ScriptOpt{inner: slice}
}
func (s *ScriptOpt) AsSlice() []byte {
	return s.inner
}

func ScriptOptDefault() ScriptOpt {
	return ScriptOptFromSliceUnchecked([]byte{})
}

func ScriptOptFromSlice(slice []byte, compatible bool) (ScriptOpt, error) {
	if len(slice) == 0 {
		return ScriptOpt{inner: slice}, errors.None()
	}

	_, err := ScriptFromSlice(slice, compatible)
	if err.NotNone() {
		return ScriptOpt{}, err
	}
	return ScriptOpt{inner: slice}, errors.None()
}

func (s *ScriptOpt) IntoScript() (Script, error) {
	if s.IsNone() {
		return Script{}, errors.New("No data")
	}
	return ScriptFromSliceUnchecked(s.AsSlice()), errors.None()
}
func (s *ScriptOpt) IsSome() bool {
	return len(s.inner) != 0
}
func (s *ScriptOpt) IsNone() bool {
	return len(s.inner) == 0
}
func (s *ScriptOpt) AsBuilder() ScriptOptBuilder {
	var ret = NewScriptOptBuilder()
	if s.IsSome() {
		ret.Set(ScriptFromSliceUnchecked(s.AsSlice()))
	}
	return ret
}

type ProposalShortIdBuilder table {
	inner [10]Byte
}

type ProposalShortId table {
	inner []byte
}

func NewProposalShortIdBuilder() ProposalShortIdBuilder {
	return ProposalShortIdBuilder{inner: [10]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *ProposalShortIdBuilder) Build() ProposalShortId {
	var b bytes.Buffer
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return ProposalShortId{inner: b.Bytes()}
}

func (s *ProposalShortIdBuilder) Set(v [10]Byte) ProposalShortIdBuilder {
	s.inner = v
	return s
}

func (s *ProposalShortIdBuilder) Nth0(v Byte) ProposalShortIdBuilder {
	s.inner[0] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth1(v Byte) ProposalShortIdBuilder {
	s.inner[1] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth2(v Byte) ProposalShortIdBuilder {
	s.inner[2] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth3(v Byte) ProposalShortIdBuilder {
	s.inner[3] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth4(v Byte) ProposalShortIdBuilder {
	s.inner[4] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth5(v Byte) ProposalShortIdBuilder {
	s.inner[5] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth6(v Byte) ProposalShortIdBuilder {
	s.inner[6] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth7(v Byte) ProposalShortIdBuilder {
	s.inner[7] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth8(v Byte) ProposalShortIdBuilder {
	s.inner[8] = v
	return s
}

func (s *ProposalShortIdBuilder) Nth9(v Byte) ProposalShortIdBuilder {
	s.inner[9] = v
	return s
}

func ProposalShortIdFromSliceUnchecked(slice []byte) ProposalShortId {
	return ProposalShortId{inner: slice}
}
func (s *ProposalShortId) AsSlice() []byte {
	return s.inner
}

func ProposalShortIdDefault() ProposalShortId {
	return ProposalShortIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ProposalShortIdFromSlice(slice []byte, _compatible bool) (ProposalShortId, error) {
	sliceLen := len(slice)
	if sliceLen != 10 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalShortId", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(10)}, " ")
		return ProposalShortId{}, errors.New(errMsg)
	}
	return ProposalShortId{inner: slice}, errors.None()
}

func (s *ProposalShortId) RawData() []byte {
	return s.inner
}

func (s *ProposalShortId) Nth0() Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *ProposalShortId) Nth1() Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *ProposalShortId) Nth2() Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *ProposalShortId) Nth3() Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *ProposalShortId) Nth4() Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *ProposalShortId) Nth5() Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *ProposalShortId) Nth6() Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *ProposalShortId) Nth7() Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *ProposalShortId) Nth8() Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *ProposalShortId) Nth9() Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *ProposalShortId) AsBuilder() ProposalShortIdBuilder {
	t := NewProposalShortIdBuilder()
	t.Nth0(s.Nth0())
	t.Nth1(s.Nth1())
	t.Nth2(s.Nth2())
	t.Nth3(s.Nth3())
	t.Nth4(s.Nth4())
	t.Nth5(s.Nth5())
	t.Nth6(s.Nth6())
	t.Nth7(s.Nth7())
	t.Nth8(s.Nth8())
	t.Nth9(s.Nth9())
	return t
}

type UncleBlock table {
	inner []byte
}

type UncleBlockVecBuilder table {
	inner []UncleBlock
}

type UncleBlockVec table {
	inner []byte
}

func (s *UncleBlockVecBuilder) Build() UncleBlockVec {
	itemCount := len(s.inner)

	var b bytes.Buffer

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return UncleBlockVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return UncleBlockVec{inner: b.Bytes()}
}

func (s *UncleBlockVecBuilder) Set(v []UncleBlock) UncleBlockVecBuilder {
	s.inner = v
	return s
}
func (s *UncleBlockVecBuilder) Push(v UncleBlock) UncleBlockVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *UncleBlockVecBuilder) Extend(iter []UncleBlock) UncleBlockVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *UncleBlockVecBuilder) Replace(index uint64, v UncleBlock) UncleBlock {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return UncleBlock{}
}

func NewUncleBlockVecBuilder() UncleBlockVecBuilder {
	return UncleBlockVecBuilder{inner: []UncleBlock{}}
}

func UncleBlockVecFromSliceUnchecked(slice []byte) UncleBlockVec {
	return UncleBlockVec{inner: slice}
}
func (s *UncleBlockVec) AsSlice() []byte {
	return s.inner
}

func UncleBlockVecDefault() UncleBlockVec {
	return UncleBlockVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func UncleBlockVecFromSlice(slice []byte, compatible bool) (UncleBlockVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UncleBlockVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return UncleBlockVec{}, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UncleBlockVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return UncleBlockVec{}, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return UncleBlockVec{inner: slice}, errors.None()
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UncleBlockVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return UncleBlockVec{}, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "UncleBlockVec", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return UncleBlockVec{}, errors.New(errMsg)
	}

	if sliceLen < int64(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UncleBlockVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
		return UncleBlockVec{}, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int64(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "UncleBlockVec"}, " ")
			return UncleBlockVec{}, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := UncleBlockFromSlice(slice[start:end], compatible)

			if err.NotNone() {
				return UncleBlockVec{}, err
			}
		}
	}

	return UncleBlockVec{inner: slice}, errors.None()
}

func (s *UncleBlockVec) TotalSize() uint64 {
	return uint64(unpackNumber(s.inner))
}
func (s *UncleBlockVec) ItemCount() uint64 {
	var number uint64 = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *UncleBlockVec) Len() uint64 {
	return s.ItemCount()
}
func (s *UncleBlockVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *UncleBlock is {}, index is out of bounds
func (s *UncleBlockVec) Get(index uint64) UncleBlock {
	var b *UncleBlock
	if index < s.Len() {
		start_index := uint64(HeaderSizeUint)  (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = UncleBlockFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint64(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = UncleBlockFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *UncleBlockVec) AsBuilder() UncleBlockVecBuilder {
	size := s.ItemCount()
	t := NewUncleBlockVecBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type TransactionVecBuilder table {
	inner []Transaction
}

type TransactionVec table {
	inner []byte
}

func (s *TransactionVecBuilder) Build() TransactionVec {
	itemCount := len(s.inner)

	var b bytes.Buffer

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return TransactionVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return TransactionVec{inner: b.Bytes()}
}

func (s *TransactionVecBuilder) Set(v []Transaction) TransactionVecBuilder {
	s.inner = v
	return s
}
func (s *TransactionVecBuilder) Push(v Transaction) TransactionVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *TransactionVecBuilder) Extend(iter []Transaction) TransactionVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *TransactionVecBuilder) Replace(index uint64, v Transaction) Transaction {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return {}
}

func NewTransactionVecBuilder() TransactionVecBuilder {
	return TransactionVecBuilder{inner: []Transaction{}}
}

func TransactionVecFromSliceUnchecked(slice []byte) TransactionVec {
	return TransactionVec{inner: slice}
}
func (s *TransactionVec) AsSlice() []byte {
	return s.inner
}

func TransactionVecDefault() TransactionVec {
	return TransactionVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func TransactionVecFromSlice(slice []byte, compatible bool) (TransactionVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransactionVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return {}, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransactionVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return {}, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return TransactionVec{inner: slice}, errors.None()
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransactionVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return {}, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransactionVec", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
		return {}, errors.New(errMsg)
	}

	if sliceLen < int64(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransactionVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
		return {}, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int64(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "TransactionVec"}, " ")
			return {}, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := TransactionFromSlice(slice[start:end], compatible)

			if err.NotNone() {
				return {}, err
			}
		}
	}

	return TransactionVec{inner: slice}, errors.None()
}

func (s *TransactionVec) TotalSize() uint64 {
	return uint64(unpackNumber(s.inner))
}
func (s *TransactionVec) ItemCount() uint64 {
	var number uint64 = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransactionVec) Len() uint64 {
	return s.ItemCount()
}
func (s *TransactionVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Transaction is {}, index is out of bounds
func (s *TransactionVec) Get(index uint64) Transaction {
	var b *Transaction
	if index < s.Len() {
		start_index := uint64(HeaderSizeUint)  (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = TransactionFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint64(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = TransactionFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *TransactionVec) AsBuilder() TransactionVecBuilder {
	size := s.ItemCount()
	t := NewTransactionVecBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type ProposalShortIdVecBuilder table {
	inner []ProposalShortId
}

type ProposalShortIdVec table {
	inner []byte
}

func (s *ProposalShortIdVecBuilder) Build() ProposalShortIdVec {
	size := packNumber(Number(len(s.inner)))

	var b bytes.Buffer

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ProposalShortIdVec{inner: b.Bytes()}

	return sb
}

func (s *ProposalShortIdVecBuilder) Set(v []ProposalShortId) ProposalShortIdVecBuilder {
	s.inner = v
	return s
}
func (s *ProposalShortIdVecBuilder) Push(v ProposalShortId) ProposalShortIdVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ProposalShortIdVecBuilder) Extend(iter []ProposalShortId) ProposalShortIdVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ProposalShortIdVecBuilder) Replace(index uint64, v ProposalShortId) ProposalShortId {
	if uint64(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return a
	}
	return {}
}

func NewProposalShortIdVecBuilder() ProposalShortIdVecBuilder {
	return ProposalShortIdVecBuilder{inner: []ProposalShortId{}}
}

func ProposalShortIdVecFromSliceUnchecked(slice []byte) ProposalShortIdVec {
	return ProposalShortIdVec{inner: slice}
}
func (s *ProposalShortIdVec) AsSlice() []byte {
	return s.inner
}

func ProposalShortIdVecDefault() ProposalShortIdVec {
	return ProposalShortIdVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ProposalShortIdVecFromSlice(slice []byte, _compatible bool) (ProposalShortIdVec, error) {
	sliceLen := len(slice)
	if sliceLen < int64(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalShortIdVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
		return {}, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int64(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalShortIdVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(HeaderSizeUint))}, " ")
			return {}, errors.New(errMsg)
		}
		return ProposalShortIdVec{inner: slice}, errors.None()
	}
	totalSize := int64(HeaderSizeUint) + int64(10*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalShortIdVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
		return {}, errors.New(errMsg)
	}
	return ProposalShortIdVec{inner: slice}, errors.None()
}

func (s *ProposalShortIdVec) TotalSize() uint64 {
	return uint64(HeaderSizeUint) + 10*s.ItemCount()
}
func (s *ProposalShortIdVec) ItemCount() uint64 {
	number := uint64(unpackNumber(s.inner))
	return number
}
func (s *ProposalShortIdVec) Len() uint64 {
	return s.ItemCount()
}
func (s *ProposalShortIdVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *ProposalShortId is {}, index is out of bounds
func (s *ProposalShortIdVec) Get(index uint64) ProposalShortId {
	var re *ProposalShortId
	if index < s.Len() {
		start := uint64(HeaderSizeUint) + 10*index
		end := start + 10
		re = ProposalShortIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ProposalShortIdVec) AsBuilder() ProposalShortIdVecBuilder {
	size := s.ItemCount()
	t := NewProposalShortIdVecBuilder()
	for i := uint64(0); i < size; i++ {
		t.Push(s.Get(i))
	}
	return t
}

type CellDepVecBuilder table {
	inner []CellDep
}

type CellDepVec table {
	inner []byte
}

func (s *CellDepVecBuilder) Build() CellDepVec {
	size := packNumber(Number(len(s.inner)))

	var b bytes.Buffer

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := CellDepVec{inner: b.Bytes()}

	return sb
}

// func (s *CellDepVecBuilder) Set(v []CellDep) CellDepVecBuilder {
// 	s.inner = v
// 	return s
// }
// func (s *CellDepVecBuilder) Push(v CellDep) CellDepVecBuilder {
// 	s.inner = append(s.inner, v)
// 	return s
// }
// func (s *CellDepVecBuilder) Extend(iter []CellDep) CellDepVecBuilder {
// 	for i := 0; i < len(iter); i++ {
// 		s.inner = append(s.inner, iter[i])
// 	}
// 	return s
// }
// func (s *CellDepVecBuilder) Replace(index uint64, v CellDep) CellDep {
// 	if uint64(len(s.inner)) > index {
// 		a := s.inner[index]
// 		s.inner[index] = v
// 		return a
// 	}
// 	return {}
// }

// func NewCellDepVecBuilder() CellDepVecBuilder {
// 	return CellDepVecBuilder{inner: []CellDep{}}
// }

// func CellDepVecFromSliceUnchecked(slice []byte) CellDepVec {
// 	return CellDepVec{inner: slice}
// }
// func (s *CellDepVec) AsSlice() []byte {
// 	return s.inner
// }

// func CellDepVecDefault() CellDepVec {
// 	return CellDepVecFromSliceUnchecked([]byte{0, 0, 0, 0})
// }

// func CellDepVecFromSlice(slice []byte, _compatible bool) (CellDepVec, error) {
// 	sliceLen := len(slice)
// 	if sliceLen < int64(HeaderSizeUint) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellDepVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	itemCount := unpackNumber(slice)
// 	if itemCount == 0 {
// 		if sliceLen != int64(HeaderSizeUint) {
// 			errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellDepVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 			return {}, errors.New(errMsg)
// 		}
// 		return CellDepVec{inner: slice}, errors.None()
// 	}
// 	totalSize := int64(HeaderSizeUint) + int64(37*itemCount)
// 	if sliceLen != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellDepVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return CellDepVec{inner: slice}, errors.None()
// }

// func (s *CellDepVec) TotalSize() uint64 {
// 	return uint64(HeaderSizeUint) + 37*s.ItemCount()
// }
// func (s *CellDepVec) ItemCount() uint64 {
// 	number := uint64(unpackNumber(s.inner))
// 	return number
// }
// func (s *CellDepVec) Len() uint64 {
// 	return s.ItemCount()
// }
// func (s *CellDepVec) IsEmpty() bool {
// 	return s.Len() == 0
// }

// // if *CellDep is {}, index is out of bounds
// func (s *CellDepVec) Get(index uint64) CellDep {
// 	var re *CellDep
// 	if index < s.Len() {
// 		start := uint64(HeaderSizeUint) + 37*index
// 		end := start + 37
// 		re = CellDepFromSliceUnchecked(s.inner[start:end])
// 	}
// 	return re
// }

// func (s *CellDepVec) AsBuilder() CellDepVecBuilder {
// 	size := s.ItemCount()
// 	t := NewCellDepVecBuilder()
// 	for i := uint64(0); i < size; i++ {
// 		t.Push(s.Get(i))
// 	}
// 	return t
// }

// type CellInputVecBuilder table {
// 	inner []CellInput
// }

// type CellInputVec table {
// 	inner []byte
// }

// func (s *CellInputVecBuilder) Build() CellInputVec {
// 	size := packNumber(Number(len(s.inner)))

// 	var b bytes.Buffer

// 	b.Write(size)
// 	len := len(s.inner)
// 	for i := 0; i < len; i++ {
// 		b.Write(s.inner[i].AsSlice())
// 	}

// 	sb := CellInputVec{inner: b.Bytes()}

// 	return sb
// }

// func (s *CellInputVecBuilder) Set(v []CellInput) CellInputVecBuilder {
// 	s.inner = v
// 	return s
// }
// func (s *CellInputVecBuilder) Push(v CellInput) CellInputVecBuilder {
// 	s.inner = append(s.inner, v)
// 	return s
// }
// func (s *CellInputVecBuilder) Extend(iter []CellInput) CellInputVecBuilder {
// 	for i := 0; i < len(iter); i++ {
// 		s.inner = append(s.inner, iter[i])
// 	}
// 	return s
// }
// func (s *CellInputVecBuilder) Replace(index uint64, v CellInput) CellInput {
// 	if uint64(len(s.inner)) > index {
// 		a := s.inner[index]
// 		s.inner[index] = v
// 		return a
// 	}
// 	return {}
// }

// func NewCellInputVecBuilder() CellInputVecBuilder {
// 	return CellInputVecBuilder{inner: []CellInput{}}
// }

// func CellInputVecFromSliceUnchecked(slice []byte) CellInputVec {
// 	return CellInputVec{inner: slice}
// }
// func (s *CellInputVec) AsSlice() []byte {
// 	return s.inner
// }

// func CellInputVecDefault() CellInputVec {
// 	return CellInputVecFromSliceUnchecked([]byte{0, 0, 0, 0})
// }

// func CellInputVecFromSlice(slice []byte, _compatible bool) (CellInputVec, error) {
// 	sliceLen := len(slice)
// 	if sliceLen < int64(HeaderSizeUint) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellInputVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	itemCount := unpackNumber(slice)
// 	if itemCount == 0 {
// 		if sliceLen != int64(HeaderSizeUint) {
// 			errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellInputVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 			return {}, errors.New(errMsg)
// 		}
// 		return CellInputVec{inner: slice}, errors.None()
// 	}
// 	totalSize := int64(HeaderSizeUint) + int64(44*itemCount)
// 	if sliceLen != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellInputVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return CellInputVec{inner: slice}, errors.None()
// }

// func (s *CellInputVec) TotalSize() uint64 {
// 	return uint64(HeaderSizeUint) + 44*s.ItemCount()
// }
// func (s *CellInputVec) ItemCount() uint64 {
// 	number := uint64(unpackNumber(s.inner))
// 	return number
// }
// func (s *CellInputVec) Len() uint64 {
// 	return s.ItemCount()
// }
// func (s *CellInputVec) IsEmpty() bool {
// 	return s.Len() == 0
// }

// // if *CellInput is {}, index is out of bounds
// func (s *CellInputVec) Get(index uint64) CellInput {
// 	var re *CellInput
// 	if index < s.Len() {
// 		start := uint64(HeaderSizeUint) + 44*index
// 		end := start + 44
// 		re = CellInputFromSliceUnchecked(s.inner[start:end])
// 	}
// 	return re
// }

// func (s *CellInputVec) AsBuilder() CellInputVecBuilder {
// 	size := s.ItemCount()
// 	t := NewCellInputVecBuilder()
// 	for i := uint64(0); i < size; i++ {
// 		t.Push(s.Get(i))
// 	}
// 	return t
// }

// type CellOutputVecBuilder table {
// 	inner []CellOutput
// }

// type CellOutputVec table {
// 	inner []byte
// }

// func (s *CellOutputVecBuilder) Build() CellOutputVec {
// 	itemCount := len(s.inner)

// 	var b bytes.Buffer

// 	// Empty dyn vector, just return size's bytes
// 	if itemCount == 0 {
// 		b.Write(packNumber(Number(HeaderSizeUint)))
// 		return CellOutputVec{inner: b.Bytes()}
// 	}

// 	// Calculate first offset then loop for rest items offsets
// 	totalSize := HeaderSizeUint * uint32(itemCount+1)
// 	offsets := make([]uint32, 0, itemCount)
// 	offsets = append(offsets, totalSize)
// 	for i := 1; i < itemCount; i++ {
// 		totalSize += uint32(len(s.inner[i-1].AsSlice()))
// 		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
// 	}
// 	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < itemCount; i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	for i := 0; i < itemCount; i++ {
// 		b.Write(s.inner[i].AsSlice())
// 	}

// 	return CellOutputVec{inner: b.Bytes()}
// }

// func (s *CellOutputVecBuilder) Set(v []CellOutput) CellOutputVecBuilder {
// 	s.inner = v
// 	return s
// }
// func (s *CellOutputVecBuilder) Push(v CellOutput) CellOutputVecBuilder {
// 	s.inner = append(s.inner, v)
// 	return s
// }
// func (s *CellOutputVecBuilder) Extend(iter []CellOutput) CellOutputVecBuilder {
// 	for i := 0; i < len(iter); i++ {
// 		s.inner = append(s.inner, iter[i])
// 	}
// 	return s
// }
// func (s *CellOutputVecBuilder) Replace(index uint64, v CellOutput) CellOutput {
// 	if uint64(len(s.inner)) > index {
// 		a := s.inner[index]
// 		s.inner[index] = v
// 		return a
// 	}
// 	return {}
// }

// func NewCellOutputVecBuilder() CellOutputVecBuilder {
// 	return CellOutputVecBuilder{inner: []CellOutput{}}
// }

// func CellOutputVecFromSliceUnchecked(slice []byte) CellOutputVec {
// 	return CellOutputVec{inner: slice}
// }
// func (s *CellOutputVec) AsSlice() []byte {
// 	return s.inner
// }

// func CellOutputVecDefault() CellOutputVec {
// 	return CellOutputVecFromSliceUnchecked([]byte{4, 0, 0, 0})
// }

// func CellOutputVecFromSlice(slice []byte, compatible bool) (CellOutputVec, error) {
// 	sliceLen := len(slice)

// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellOutputVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellOutputVec", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) == HeaderSizeUint {
// 		return CellOutputVec{inner: slice}, errors.None()
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellOutputVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "CellOutputVec", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellOutputVec", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

// 	offsets := make([]uint32, itemCount)

// 	for i := 0; i < int64(itemCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}

// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			errMsg := strings.Join([]string{"OffsetsNotMatch", "CellOutputVec"}, " ")
// 			return {}, errors.New(errMsg)
// 		}
// 	}

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 {
// 			start := offsets[i-1]
// 			end := offsets[i]
// 			_, err := CellOutputFromSlice(slice[start:end], compatible)

// 			if err.NotNone() {
// 				return {}, err
// 			}
// 		}
// 	}

// 	return CellOutputVec{inner: slice}, errors.None()
// }

// func (s *CellOutputVec) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *CellOutputVec) ItemCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *CellOutputVec) Len() uint64 {
// 	return s.ItemCount()
// }
// func (s *CellOutputVec) IsEmpty() bool {
// 	return s.Len() == 0
// }

// // if *CellOutput is {}, index is out of bounds
// func (s *CellOutputVec) Get(index uint64) CellOutput {
// 	var b *CellOutput
// 	if index < s.Len() {
// 		start_index := uint64(HeaderSizeUint)  (1 + index)
// 		start := unpackNumber(s.inner[start_index:])

// 		if index == s.Len()-1 {
// 			b = CellOutputFromSliceUnchecked(s.inner[start:])
// 		} else {
// 			end_index := start_index + uint64(HeaderSizeUint)
// 			end := unpackNumber(s.inner[end_index:])
// 			b = CellOutputFromSliceUnchecked(s.inner[start:end])
// 		}
// 	}
// 	return b
// }

// func (s *CellOutputVec) AsBuilder() CellOutputVecBuilder {
// 	size := s.ItemCount()
// 	t := NewCellOutputVecBuilder()
// 	for i := uint64(0); i < size; i++ {
// 		t.Push(s.Get(i))
// 	}
// 	return t
// }

// type ScriptBuilder table {
// 	code_hash Byte32
// 	hash_type Byte
// 	args      Bytes
// }

// func (s *ScriptBuilder) Build() Script {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (3 + 1)
// 	offsets := make([]uint32, 0, 3)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.code_hash.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.hash_type.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.args.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.code_hash.AsSlice())
// 	b.Write(s.hash_type.AsSlice())
// 	b.Write(s.args.AsSlice())
// 	return Script{inner: b.Bytes()}
// }

// func (s *ScriptBuilder) CodeHash(v Byte32) ScriptBuilder {
// 	s.code_hash = v
// 	return s
// }

// func (s *ScriptBuilder) HashType(v Byte) ScriptBuilder {
// 	s.hash_type = v
// 	return s
// }

// func (s *ScriptBuilder) Args(v Bytes) ScriptBuilder {
// 	s.args = v
// 	return s
// }

// func NewScriptBuilder() ScriptBuilder {
// 	return ScriptBuilder{code_hash: Byte32Default(), hash_type: ByteDefault(), args: BytesDefault()}
// }

// func ScriptFromSliceUnchecked(slice []byte) Script {
// 	return Script{inner: slice}
// }
// func (s *Script) AsSlice() []byte {
// 	return s.inner
// }

// func ScriptDefault() Script {
// 	return ScriptFromSliceUnchecked([]byte{53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func ScriptFromSlice(slice []byte, compatible bool) (Script, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Script", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Script", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Script", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "Script", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Script", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	notMatch := !compatible
// 	notMatch = notMatch && fieldCount > 3
// 	if fieldCount < 3 || notMatch{
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = Byte32FromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = ByteFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return Script{inner: slice}, errors.None()
// }

// func (s *Script) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *Script) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *Script) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *Script) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *Script) CountExtraFields() uint64 {
// 	return s.FieldCount() - 3
// }

// func (s *Script) HasExtraFields() bool {
// 	return 3 != s.FieldCount()
// }

// func (s *Script) CodeHash() Byte32 {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return Byte32FromSliceUnchecked(s.inner[start:end])
// }

// func (s *Script) HashType() Byte {
// 	start := unpackNumber(s.inner[8:])
// 	end := unpackNumber(s.inner[12:])
// 	return ByteFromSliceUnchecked(s.inner[start:end])
// }

// func (s *Script) Args() Bytes {
// 	var ret *Bytes
// 	start := unpackNumber(s.inner[12:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[16:])
// 		ret = BytesFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = BytesFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *Script) AsBuilder() ScriptBuilder {
// 	ret := NewScriptBuilder().CodeHash(s.CodeHash()).HashType(s.HashType()).Args(s.Args())
// 	return ret
// }

// type OutPointBuilder table {
// 	tx_hash Byte32
// 	index   Uint32
// }

// type OutPoint table {
// 	inner []byte
// }

// func (s *OutPointBuilder) Build() OutPoint {
// 	var b bytes.Buffer
// 	b.Write(s.tx_hash.AsSlice())
// 	b.Write(s.index.AsSlice())
// 	return OutPoint{inner: b.Bytes()}
// }

// func (s *OutPointBuilder) TxHash(v Byte32) OutPointBuilder {
// 	s.tx_hash = v
// 	return s
// }

// func (s *OutPointBuilder) Index(v Uint32) OutPointBuilder {
// 	s.index = v
// 	return s
// }

// func NewOutPointBuilder() OutPointBuilder {
// 	return OutPointBuilder{tx_hash: Byte32Default(), index: Uint32Default()}
// }

// func OutPointFromSliceUnchecked(slice []byte) OutPoint {
// 	return OutPoint{inner: slice}
// }
// func (s *OutPoint) AsSlice() []byte {
// 	return s.inner
// }

// func OutPointDefault() OutPoint {
// 	return OutPointFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func OutPointFromSlice(slice []byte, _compatible bool) (OutPoint, error) {
// 	sliceLen := len(slice)
// 	if sliceLen != 36 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OutPoint", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(36)}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return OutPoint{inner: slice}, errors.None()
// }

// func (s *OutPoint) TxHash() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[0:32])
// 	return ret
// }

// func (s *OutPoint) Index() Uint32 {
// 	ret := Uint32FromSliceUnchecked(s.inner[32:36])
// 	return ret
// }

// func (s *OutPoint) AsBuilder() OutPointBuilder {
// 	ret := NewOutPointBuilder().TxHash(s.TxHash()).Index(s.Index())
// 	return ret
// }

// type CellInputBuilder table {
// 	since           Uint64
// 	previous_output OutPoint
// }

// type CellInput table {
// 	inner []byte
// }

// func (s *CellInputBuilder) Build() CellInput {
// 	var b bytes.Buffer
// 	b.Write(s.since.AsSlice())
// 	b.Write(s.previous_output.AsSlice())
// 	return CellInput{inner: b.Bytes()}
// }

// func (s *CellInputBuilder) Since(v Uint64) CellInputBuilder {
// 	s.since = v
// 	return s
// }

// func (s *CellInputBuilder) PreviousOutput(v OutPoint) CellInputBuilder {
// 	s.previous_output = v
// 	return s
// }

// func NewCellInputBuilder() CellInputBuilder {
// 	return CellInputBuilder{since: Uint64Default(), previous_output: OutPointDefault()}
// }

// func CellInputFromSliceUnchecked(slice []byte) CellInput {
// 	return CellInput{inner: slice}
// }
// func (s *CellInput) AsSlice() []byte {
// 	return s.inner
// }

// func CellInputDefault() CellInput {
// 	return CellInputFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func CellInputFromSlice(slice []byte, _compatible bool) (CellInput, error) {
// 	sliceLen := len(slice)
// 	if sliceLen != 44 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellInput", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(44)}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return CellInput{inner: slice}, errors.None()
// }

// func (s *CellInput) Since() Uint64 {
// 	ret := Uint64FromSliceUnchecked(s.inner[0:8])
// 	return ret
// }

// func (s *CellInput) PreviousOutput() OutPoint {
// 	ret := OutPointFromSliceUnchecked(s.inner[8:44])
// 	return ret
// }

// func (s *CellInput) AsBuilder() CellInputBuilder {
// 	ret := NewCellInputBuilder().Since(s.Since()).PreviousOutput(s.PreviousOutput())
// 	return ret
// }

// type CellOutputBuilder table {
// 	capacity Uint64
// 	lock     Script
// 	type_    ScriptOpt
// }

// type CellOutput table {
// 	inner []byte
// }

// func (s *CellOutputBuilder) Build() CellOutput {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (3 + 1)
// 	offsets := make([]uint32, 0, 3)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.capacity.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.lock.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.type_.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.capacity.AsSlice())
// 	b.Write(s.lock.AsSlice())
// 	b.Write(s.type_.AsSlice())
// 	return CellOutput{inner: b.Bytes()}
// }

// func (s *CellOutputBuilder) Capacity(v Uint64) CellOutputBuilder {
// 	s.capacity = v
// 	return s
// }

// func (s *CellOutputBuilder) Lock(v Script) CellOutputBuilder {
// 	s.lock = v
// 	return s
// }

// func (s *CellOutputBuilder) Type(v ScriptOpt) CellOutputBuilder {
// 	s.type_ = v
// 	return s
// }

// func NewCellOutputBuilder() CellOutputBuilder {
// 	return CellOutputBuilder{capacity: Uint64Default(), lock: ScriptDefault(), type_: ScriptOptDefault()}
// }

// func CellOutputFromSliceUnchecked(slice []byte) CellOutput {
// 	return CellOutput{inner: slice}
// }
// func (s *CellOutput) AsSlice() []byte {
// 	return s.inner
// }

// func CellOutputDefault() CellOutput {
// 	return CellOutputFromSliceUnchecked([]byte{77, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func CellOutputFromSlice(slice []byte, compatible bool) (CellOutput, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellOutput", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellOutput", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellOutput", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "CellOutput", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellOutput", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 3 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if fieldCount > 3 {
// 		if !compatible {
// 			return {}, errors.New("FieldCountNotMatch")
// 		}
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = ScriptOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return CellOutput{inner: slice}, errors.None()
// }

// func (s *CellOutput) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *CellOutput) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *CellOutput) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *CellOutput) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *CellOutput) CountExtraFields() uint64 {
// 	return s.FieldCount() - 3
// }

// func (s *CellOutput) HasExtraFields() bool {
// 	return 3 != s.FieldCount()
// }

// func (s *CellOutput) Capacity() Uint64 {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return Uint64FromSliceUnchecked(s.inner[start:end])
// }

// func (s *CellOutput) Lock() Script {
// 	start := unpackNumber(s.inner[8:])
// 	end := unpackNumber(s.inner[12:])
// 	return ScriptFromSliceUnchecked(s.inner[start:end])
// }

// func (s *CellOutput) Type() ScriptOpt {
// 	var ret *ScriptOpt
// 	start := unpackNumber(s.inner[12:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[16:])
// 		ret = ScriptOptFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = ScriptOptFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *CellOutput) AsBuilder() CellOutputBuilder {
// 	ret := NewCellOutputBuilder().Capacity(s.Capacity()).Lock(s.Lock()).Type(s.Type())
// 	return ret
// }

// type CellDepBuilder table {
// 	out_point OutPoint
// 	dep_type  Byte
// }

// type CellDep table {
// 	inner []byte
// }

// func (s *CellDepBuilder) Build() CellDep {
// 	var b bytes.Buffer
// 	b.Write(s.out_point.AsSlice())
// 	b.Write(s.dep_type.AsSlice())
// 	return CellDep{inner: b.Bytes()}
// }

// func (s *CellDepBuilder) OutPoint64(v OutPoint) CellDepBuilder {
// 	s.out_point = v
// 	return s
// }

// func (s *CellDepBuilder) DepType(v Byte) CellDepBuilder {
// 	s.dep_type = v
// 	return s
// }

// func NewCellDepBuilder() CellDepBuilder {
// 	return CellDepBuilder{out_point: OutPointDefault(), dep_type: ByteDefault()}
// }

// func CellDepFromSliceUnchecked(slice []byte) CellDep {
// 	return CellDep{inner: slice}
// }
// func (s *CellDep) AsSlice() []byte {
// 	return s.inner
// }

// func CellDepDefault() CellDep {
// 	return CellDepFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func CellDepFromSlice(slice []byte, _compatible bool) (CellDep, error) {
// 	sliceLen := len(slice)
// 	if sliceLen != 37 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellDep", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(37)}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return CellDep{inner: slice}, errors.None()
// }

// func (s *CellDep) OutPoint64() OutPoint {
// 	ret := OutPointFromSliceUnchecked(s.inner[0:36])
// 	return ret
// }

// func (s *CellDep) DepType() Byte {
// 	ret := ByteFromSliceUnchecked(s.inner[36:37])
// 	return ret
// }

// func (s *CellDep) AsBuilder() CellDepBuilder {
// 	ret := NewCellDepBuilder().OutPoint64(s.OutPoint64()).DepType(s.DepType())
// 	return ret
// }

// type RawTransactionBuilder table {
// 	version      Uint32
// 	cell_deps    CellDepVec
// 	header_deps  Byte32Vec
// 	inputs       CellInputVec
// 	outputs      CellOutputVec
// 	outputs_data BytesVec
// }

// type RawTransaction table {
// 	inner []byte
// }

// func (s *RawTransactionBuilder) Build() RawTransaction {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (6 + 1)
// 	offsets := make([]uint32, 0, 6)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.version.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.cell_deps.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.header_deps.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.inputs.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.outputs.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.outputs_data.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.version.AsSlice())
// 	b.Write(s.cell_deps.AsSlice())
// 	b.Write(s.header_deps.AsSlice())
// 	b.Write(s.inputs.AsSlice())
// 	b.Write(s.outputs.AsSlice())
// 	b.Write(s.outputs_data.AsSlice())
// 	return RawTransaction{inner: b.Bytes()}
// }

// func (s *RawTransactionBuilder) Version(v Uint32) RawTransactionBuilder {
// 	s.version = v
// 	return s
// }

// func (s *RawTransactionBuilder) CellDeps(v CellDepVec) RawTransactionBuilder {
// 	s.cell_deps = v
// 	return s
// }

// func (s *RawTransactionBuilder) HeaderDeps(v Byte32Vec) RawTransactionBuilder {
// 	s.header_deps = v
// 	return s
// }

// func (s *RawTransactionBuilder) Inputs(v CellInputVec) RawTransactionBuilder {
// 	s.inputs = v
// 	return s
// }

// func (s *RawTransactionBuilder) Outputs(v CellOutputVec) RawTransactionBuilder {
// 	s.outputs = v
// 	return s
// }

// func (s *RawTransactionBuilder) OutputsData(v BytesVec) RawTransactionBuilder {
// 	s.outputs_data = v
// 	return s
// }

// func NewRawTransactionBuilder() RawTransactionBuilder {
// 	return RawTransactionBuilder{version: Uint32Default(), cell_deps: CellDepVecDefault(), header_deps: Byte32VecDefault(), inputs: CellInputVecDefault(), outputs: CellOutputVecDefault(), outputs_data: BytesVecDefault()}
// }

// func RawTransactionFromSliceUnchecked(slice []byte) RawTransaction {
// 	return RawTransaction{inner: slice}
// }
// func (s *RawTransaction) AsSlice() []byte {
// 	return s.inner
// }

// func RawTransactionDefault() RawTransaction {
// 	return RawTransactionFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0})
// }

// func RawTransactionFromSlice(slice []byte, compatible bool) (RawTransaction, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "RawTransaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RawTransaction", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RawTransaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "RawTransaction", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "RawTransaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 6 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 6 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = CellDepVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = Byte32VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = CellInputVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = CellOutputVecFromSlice(slice[offsets[4]:offsets[5]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesVecFromSlice(slice[offsets[5]:offsets[6]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return RawTransaction{inner: slice}, errors.None()
// }

// func (s *RawTransaction) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *RawTransaction) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *RawTransaction) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *RawTransaction) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *RawTransaction) CountExtraFields() uint64 {
// 	return s.FieldCount() - 6
// }

// func (s *RawTransaction) HasExtraFields() bool {
// 	return 6 != s.FieldCount()
// }

// func (s *RawTransaction) Version() Uint32 {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return Uint32FromSliceUnchecked(s.inner[start:end])
// }

// func (s *RawTransaction) CellDeps() CellDepVec {
// 	start := unpackNumber(s.inner[8:])
// 	end := unpackNumber(s.inner[12:])
// 	return CellDepVecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *RawTransaction) HeaderDeps() Byte32Vec {
// 	start := unpackNumber(s.inner[12:])
// 	end := unpackNumber(s.inner[16:])
// 	return Byte32VecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *RawTransaction) Inputs() CellInputVec {
// 	start := unpackNumber(s.inner[16:])
// 	end := unpackNumber(s.inner[20:])
// 	return CellInputVecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *RawTransaction) Outputs() CellOutputVec {
// 	start := unpackNumber(s.inner[20:])
// 	end := unpackNumber(s.inner[24:])
// 	return CellOutputVecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *RawTransaction) OutputsData() BytesVec {
// 	var ret *BytesVec
// 	start := unpackNumber(s.inner[24:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[28:])
// 		ret = BytesVecFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = BytesVecFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *RawTransaction) AsBuilder() RawTransactionBuilder {
// 	ret := NewRawTransactionBuilder().Version(s.Version()).CellDeps(s.CellDeps()).HeaderDeps(s.HeaderDeps()).Inputs(s.Inputs()).Outputs(s.Outputs()).OutputsData(s.OutputsData())
// 	return ret
// }

// type TransactionBuilder table {
// 	raw       RawTransaction
// 	witnesses BytesVec
// }

// type Transaction table {
// 	inner []byte
// }

// func (s *TransactionBuilder) Build() Transaction {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (2 + 1)
// 	offsets := make([]uint32, 0, 2)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.raw.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.witnesses.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.raw.AsSlice())
// 	b.Write(s.witnesses.AsSlice())
// 	return Transaction{inner: b.Bytes()}
// }

// func (s *TransactionBuilder) Raw(v RawTransaction) TransactionBuilder {
// 	s.raw = v
// 	return s
// }

// func (s *TransactionBuilder) Witnesses(v BytesVec) TransactionBuilder {
// 	s.witnesses = v
// 	return s
// }

// func NewTransactionBuilder() TransactionBuilder {
// 	return TransactionBuilder{raw: RawTransactionDefault(), witnesses: BytesVecDefault()}
// }

// func TransactionFromSliceUnchecked(slice []byte) Transaction {
// 	return Transaction{inner: slice}
// }
// func (s *Transaction) AsSlice() []byte {
// 	return s.inner
// }

// func TransactionDefault() Transaction {
// 	return TransactionFromSliceUnchecked([]byte{68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0})
// }

// func TransactionFromSlice(slice []byte, compatible bool) (Transaction, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Transaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Transaction", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Transaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "Transaction", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Transaction", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = RawTransactionFromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return Transaction{inner: slice}, errors.None()
// }

// func (s *Transaction) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *Transaction) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *Transaction) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *Transaction) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *Transaction) CountExtraFields() uint64 {
// 	return s.FieldCount() - 2
// }

// func (s *Transaction) HasExtraFields() bool {
// 	return 2 != s.FieldCount()
// }

// func (s *Transaction) Raw() RawTransaction {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return RawTransactionFromSliceUnchecked(s.inner[start:end])
// }

// func (s *Transaction) Witnesses() BytesVec {
// 	var ret *BytesVec
// 	start := unpackNumber(s.inner[8:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[12:])
// 		ret = BytesVecFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = BytesVecFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *Transaction) AsBuilder() TransactionBuilder {
// 	ret := NewTransactionBuilder().Raw(s.Raw()).Witnesses(s.Witnesses())
// 	return ret
// }

// type RawHeaderBuilder table {
// 	version           Uint32
// 	compact_target    Uint32
// 	timestamp         Uint64
// 	number            Uint64
// 	epoch             Uint64
// 	parent_hash       Byte32
// 	transactions_root Byte32
// 	proposals_hash    Byte32
// 	uncles_hash       Byte32
// 	dao               Byte32
// }

// type RawHeader table {
// 	inner []byte
// }

// func (s *RawHeaderBuilder) Build() RawHeader {
// 	var b bytes.Buffer
// 	b.Write(s.version.AsSlice())
// 	b.Write(s.compact_target.AsSlice())
// 	b.Write(s.timestamp.AsSlice())
// 	b.Write(s.number.AsSlice())
// 	b.Write(s.epoch.AsSlice())
// 	b.Write(s.parent_hash.AsSlice())
// 	b.Write(s.transactions_root.AsSlice())
// 	b.Write(s.proposals_hash.AsSlice())
// 	b.Write(s.uncles_hash.AsSlice())
// 	b.Write(s.dao.AsSlice())
// 	return RawHeader{inner: b.Bytes()}
// }

// func (s *RawHeaderBuilder) Version(v Uint32) RawHeaderBuilder {
// 	s.version = v
// 	return s
// }

// func (s *RawHeaderBuilder) CompactTarget(v Uint32) RawHeaderBuilder {
// 	s.compact_target = v
// 	return s
// }

// func (s *RawHeaderBuilder) Timestamp(v Uint64) RawHeaderBuilder {
// 	s.timestamp = v
// 	return s
// }

// func (s *RawHeaderBuilder) Number(v Uint64) RawHeaderBuilder {
// 	s.number = v
// 	return s
// }

// func (s *RawHeaderBuilder) Epoch(v Uint64) RawHeaderBuilder {
// 	s.epoch = v
// 	return s
// }

// func (s *RawHeaderBuilder) ParentHash(v Byte32) RawHeaderBuilder {
// 	s.parent_hash = v
// 	return s
// }

// func (s *RawHeaderBuilder) TransactionsRoot(v Byte32) RawHeaderBuilder {
// 	s.transactions_root = v
// 	return s
// }

// func (s *RawHeaderBuilder) ProposalsHash(v Byte32) RawHeaderBuilder {
// 	s.proposals_hash = v
// 	return s
// }

// func (s *RawHeaderBuilder) UnclesHash(v Byte32) RawHeaderBuilder {
// 	s.uncles_hash = v
// 	return s
// }

// func (s *RawHeaderBuilder) Dao(v Byte32) RawHeaderBuilder {
// 	s.dao = v
// 	return s
// }

// func NewRawHeaderBuilder() RawHeaderBuilder {
// 	return RawHeaderBuilder{version: Uint32Default(), compact_target: Uint32Default(), timestamp: Uint64Default(), number: Uint64Default(), epoch: Uint64Default(), parent_hash: Byte32Default(), transactions_root: Byte32Default(), proposals_hash: Byte32Default(), uncles_hash: Byte32Default(), dao: Byte32Default()}
// }

// func RawHeaderFromSliceUnchecked(slice []byte) RawHeader {
// 	return RawHeader{inner: slice}
// }
// func (s *RawHeader) AsSlice() []byte {
// 	return s.inner
// }

// func RawHeaderDefault() RawHeader {
// 	return RawHeaderFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func RawHeaderFromSlice(slice []byte, _compatible bool) (RawHeader, error) {
// 	sliceLen := len(slice)
// 	if sliceLen != 192 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RawHeader", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(192)}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return RawHeader{inner: slice}, errors.None()
// }

// func (s *RawHeader) Version() Uint32 {
// 	ret := Uint32FromSliceUnchecked(s.inner[0:4])
// 	return ret
// }

// func (s *RawHeader) CompactTarget() Uint32 {
// 	ret := Uint32FromSliceUnchecked(s.inner[4:8])
// 	return ret
// }

// func (s *RawHeader) Timestamp() Uint64 {
// 	ret := Uint64FromSliceUnchecked(s.inner[8:16])
// 	return ret
// }

// func (s *RawHeader) Number() Uint64 {
// 	ret := Uint64FromSliceUnchecked(s.inner[16:24])
// 	return ret
// }

// func (s *RawHeader) Epoch() Uint64 {
// 	ret := Uint64FromSliceUnchecked(s.inner[24:32])
// 	return ret
// }

// func (s *RawHeader) ParentHash() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[32:64])
// 	return ret
// }

// func (s *RawHeader) TransactionsRoot() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[64:96])
// 	return ret
// }

// func (s *RawHeader) ProposalsHash() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[96:128])
// 	return ret
// }

// func (s *RawHeader) UnclesHash() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[128:160])
// 	return ret
// }

// func (s *RawHeader) Dao() Byte32 {
// 	ret := Byte32FromSliceUnchecked(s.inner[160:192])
// 	return ret
// }

// func (s *RawHeader) AsBuilder() RawHeaderBuilder {
// 	ret := NewRawHeaderBuilder().Version(s.Version()).CompactTarget(s.CompactTarget()).Timestamp(s.Timestamp()).Number(s.Number()).Epoch(s.Epoch()).ParentHash(s.ParentHash()).TransactionsRoot(s.TransactionsRoot()).ProposalsHash(s.ProposalsHash()).UnclesHash(s.UnclesHash()).Dao(s.Dao())
// 	return ret
// }

// type HeaderBuilder table {
// 	raw   RawHeader
// 	nonce Uint128
// }

// type Header table {
// 	inner []byte
// }

// func (s *HeaderBuilder) Build() Header {
// 	var b bytes.Buffer
// 	b.Write(s.raw.AsSlice())
// 	b.Write(s.nonce.AsSlice())
// 	return Header{inner: b.Bytes()}
// }

// func (s *HeaderBuilder) Raw(v RawHeader) HeaderBuilder {
// 	s.raw = v
// 	return s
// }

// func (s *HeaderBuilder) Nonce(v Uint128) HeaderBuilder {
// 	s.nonce = v
// 	return s
// }

// func NewHeaderBuilder() HeaderBuilder {
// 	return HeaderBuilder{raw: RawHeaderDefault(), nonce: Uint128Default()}
// }

// func HeaderFromSliceUnchecked(slice []byte) Header {
// 	return Header{inner: slice}
// }
// func (s *Header) AsSlice() []byte {
// 	return s.inner
// }

// func HeaderDefault() Header {
// 	return HeaderFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func HeaderFromSlice(slice []byte, _compatible bool) (Header, error) {
// 	sliceLen := len(slice)
// 	if sliceLen != 208 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Header", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(208)}, " ")
// 		return {}, errors.New(errMsg)
// 	}
// 	return Header{inner: slice}, errors.None()
// }

// func (s *Header) Raw() RawHeader {
// 	ret := RawHeaderFromSliceUnchecked(s.inner[0:192])
// 	return ret
// }

// func (s *Header) Nonce() Uint128 {
// 	ret := Uint128FromSliceUnchecked(s.inner[192:208])
// 	return ret
// }

// func (s *Header) AsBuilder() HeaderBuilder {
// 	ret := NewHeaderBuilder().Raw(s.Raw()).Nonce(s.Nonce())
// 	return ret
// }

// type UncleBlockBuilder table {
// 	header    Header
// 	proposals ProposalShortIdVec
// }

// func (s *UncleBlockBuilder) Build() UncleBlock {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (2 + 1)
// 	offsets := make([]uint32, 0, 2)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.header.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.proposals.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.header.AsSlice())
// 	b.Write(s.proposals.AsSlice())
// 	return UncleBlock{inner: b.Bytes()}
// }

// func (s *UncleBlockBuilder) Header(v Header) UncleBlockBuilder {
// 	s.header = v
// 	return s
// }

// func (s *UncleBlockBuilder) Proposals(v ProposalShortIdVec) UncleBlockBuilder {
// 	s.proposals = v
// 	return s
// }

// func NewUncleBlockBuilder() UncleBlockBuilder {
// 	return UncleBlockBuilder{header: HeaderDefault(), proposals: ProposalShortIdVecDefault()}
// }

// func UncleBlockFromSliceUnchecked(slice []byte) UncleBlock {
// 	return UncleBlock{inner: slice}
// }
// func (s *UncleBlock) AsSlice() []byte {
// 	return s.inner
// }

// func UncleBlockDefault() UncleBlock {
// 	return UncleBlockFromSliceUnchecked([]byte{224, 0, 0, 0, 12, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func UncleBlockFromSlice(slice []byte, compatible bool) (UncleBlock, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "UncleBlock", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UncleBlock", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UncleBlock", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "UncleBlock", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "UncleBlock", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = HeaderFromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = ProposalShortIdVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return UncleBlock{inner: slice}, errors.None()
// }

// func (s *UncleBlock) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *UncleBlock) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *UncleBlock) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *UncleBlock) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *UncleBlock) CountExtraFields() uint64 {
// 	return s.FieldCount() - 2
// }

// func (s *UncleBlock) HasExtraFields() bool {
// 	return 2 != s.FieldCount()
// }

// func (s *UncleBlock) Header() Header {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return HeaderFromSliceUnchecked(s.inner[start:end])
// }

// func (s *UncleBlock) Proposals() ProposalShortIdVec {
// 	var ret *ProposalShortIdVec
// 	start := unpackNumber(s.inner[8:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[12:])
// 		ret = ProposalShortIdVecFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = ProposalShortIdVecFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *UncleBlock) AsBuilder() UncleBlockBuilder {
// 	ret := NewUncleBlockBuilder().Header(s.Header()).Proposals(s.Proposals())
// 	return ret
// }

// type BlockBuilder table {
// 	header       Header
// 	uncles       UncleBlockVec
// 	transactions TransactionVec
// 	proposals    ProposalShortIdVec
// }

// type Block table {
// 	inner []byte
// }

// func (s *BlockBuilder) Build() Block {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (4 + 1)
// 	offsets := make([]uint32, 0, 4)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.header.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.uncles.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.transactions.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.proposals.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.header.AsSlice())
// 	b.Write(s.uncles.AsSlice())
// 	b.Write(s.transactions.AsSlice())
// 	b.Write(s.proposals.AsSlice())
// 	return Block{inner: b.Bytes()}
// }

// func (s *BlockBuilder) Header(v Header) BlockBuilder {
// 	s.header = v
// 	return s
// }

// func (s *BlockBuilder) Uncles(v UncleBlockVec) BlockBuilder {
// 	s.uncles = v
// 	return s
// }

// func (s *BlockBuilder) Transactions(v TransactionVec) BlockBuilder {
// 	s.transactions = v
// 	return s
// }

// func (s *BlockBuilder) Proposals(v ProposalShortIdVec) BlockBuilder {
// 	s.proposals = v
// 	return s
// }

// func NewBlockBuilder() BlockBuilder {
// 	return BlockBuilder{header: HeaderDefault(), uncles: UncleBlockVecDefault(), transactions: TransactionVecDefault(), proposals: ProposalShortIdVecDefault()}
// }

// func BlockFromSliceUnchecked(slice []byte) Block {
// 	return Block{inner: slice}
// }
// func (s *Block) AsSlice() []byte {
// 	return s.inner
// }

// func BlockDefault() Block {
// 	return BlockFromSliceUnchecked([]byte{240, 0, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0})
// }

// func BlockFromSlice(slice []byte, compatible bool) (Block, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Block", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Block", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Block", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "Block", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "Block", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 4 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 4 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = HeaderFromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = UncleBlockVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = TransactionVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = ProposalShortIdVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return Block{inner: slice}, errors.None()
// }

// func (s *Block) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *Block) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *Block) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *Block) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *Block) CountExtraFields() uint64 {
// 	return s.FieldCount() - 4
// }

// func (s *Block) HasExtraFields() bool {
// 	return 4 != s.FieldCount()
// }

// func (s *Block) Header() Header {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return HeaderFromSliceUnchecked(s.inner[start:end])
// }

// func (s *Block) Uncles() UncleBlockVec {
// 	start := unpackNumber(s.inner[8:])
// 	end := unpackNumber(s.inner[12:])
// 	return UncleBlockVecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *Block) Transactions() TransactionVec {
// 	start := unpackNumber(s.inner[12:])
// 	end := unpackNumber(s.inner[16:])
// 	return TransactionVecFromSliceUnchecked(s.inner[start:end])
// }

// func (s *Block) Proposals() ProposalShortIdVec {
// 	var ret *ProposalShortIdVec
// 	start := unpackNumber(s.inner[16:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[20:])
// 		ret = ProposalShortIdVecFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = ProposalShortIdVecFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *Block) AsBuilder() BlockBuilder {
// 	ret := NewBlockBuilder().Header(s.Header()).Uncles(s.Uncles()).Transactions(s.Transactions()).Proposals(s.Proposals())
// 	return ret
// }

// type CellbaseWitnessBuilder table {
// 	lock    Script
// 	message Bytes
// }

// type CellbaseWitness table {
// 	inner []byte
// }

// func (s *CellbaseWitnessBuilder) Build() CellbaseWitness {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (2 + 1)
// 	offsets := make([]uint32, 0, 2)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.lock.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.message.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.lock.AsSlice())
// 	b.Write(s.message.AsSlice())
// 	return CellbaseWitness{inner: b.Bytes()}
// }

// func (s *CellbaseWitnessBuilder) Lock(v Script) CellbaseWitnessBuilder {
// 	s.lock = v
// 	return s
// }

// func (s *CellbaseWitnessBuilder) Message(v Bytes) CellbaseWitnessBuilder {
// 	s.message = v
// 	return s
// }

// func NewCellbaseWitnessBuilder() CellbaseWitnessBuilder {
// 	return CellbaseWitnessBuilder{lock: ScriptDefault(), message: BytesDefault()}
// }

// func CellbaseWitnessFromSliceUnchecked(slice []byte) CellbaseWitness {
// 	return CellbaseWitness{inner: slice}
// }
// func (s *CellbaseWitness) AsSlice() []byte {
// 	return s.inner
// }

// func CellbaseWitnessDefault() CellbaseWitness {
// 	return CellbaseWitnessFromSliceUnchecked([]byte{69, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
// }

// func CellbaseWitnessFromSlice(slice []byte, compatible bool) (CellbaseWitness, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellbaseWitness", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellbaseWitness", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CellbaseWitness", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "CellbaseWitness", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "CellbaseWitness", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 2 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return CellbaseWitness{inner: slice}, errors.None()
// }

// func (s *CellbaseWitness) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *CellbaseWitness) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *CellbaseWitness) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *CellbaseWitness) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *CellbaseWitness) CountExtraFields() uint64 {
// 	return s.FieldCount() - 2
// }

// func (s *CellbaseWitness) HasExtraFields() bool {
// 	return 2 != s.FieldCount()
// }

// func (s *CellbaseWitness) Lock() Script {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return ScriptFromSliceUnchecked(s.inner[start:end])
// }

// func (s *CellbaseWitness) Message() Bytes {
// 	var ret *Bytes
// 	start := unpackNumber(s.inner[8:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[12:])
// 		ret = BytesFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = BytesFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *CellbaseWitness) AsBuilder() CellbaseWitnessBuilder {
// 	ret := NewCellbaseWitnessBuilder().Lock(s.Lock()).Message(s.Message())
// 	return ret
// }

// type WitnessArgsBuilder table {
// 	lock        BytesOpt
// 	input_type  BytesOpt
// 	output_type BytesOpt
// }

// type WitnessArgs table {
// 	inner []byte
// }

// func (s *WitnessArgsBuilder) Build() WitnessArgs {
// 	var b bytes.Buffer

// 	totalSize := HeaderSizeUint * (3 + 1)
// 	offsets := make([]uint32, 0, 3)

// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.lock.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.input_type.AsSlice()))
// 	offsets = append(offsets, totalSize)
// 	totalSize += uint32(len(s.output_type.AsSlice()))

// 	b.Write(packNumber(Number(totalSize)))

// 	for i := 0; i < len(offsets); i++ {
// 		b.Write(packNumber(Number(offsets[i])))
// 	}

// 	b.Write(s.lock.AsSlice())
// 	b.Write(s.input_type.AsSlice())
// 	b.Write(s.output_type.AsSlice())
// 	return WitnessArgs{inner: b.Bytes()}
// }

// func (s *WitnessArgsBuilder) Lock(v BytesOpt) WitnessArgsBuilder {
// 	s.lock = v
// 	return s
// }

// func (s *WitnessArgsBuilder) InputType(v BytesOpt) WitnessArgsBuilder {
// 	s.input_type = v
// 	return s
// }

// func (s *WitnessArgsBuilder) OutputType(v BytesOpt) WitnessArgsBuilder {
// 	s.output_type = v
// 	return s
// }

// func NewWitnessArgsBuilder() WitnessArgsBuilder {
// 	return WitnessArgsBuilder{lock: BytesOptDefault(), input_type: BytesOptDefault(), output_type: BytesOptDefault()}
// }

// func WitnessArgsFromSliceUnchecked(slice []byte) WitnessArgs {
// 	return WitnessArgs{inner: slice}
// }
// func (s *WitnessArgs) AsSlice() []byte {
// 	return s.inner
// }

// func WitnessArgsDefault() WitnessArgs {
// 	return WitnessArgsFromSliceUnchecked([]byte{16, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0})
// }

// func WitnessArgsFromSlice(slice []byte, compatible bool) (WitnessArgs, error) {
// 	sliceLen := len(slice)
// 	if uint32(sliceLen) < HeaderSizeUint {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "WitnessArgs", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	totalSize := unpackNumber(slice)
// 	if Number(sliceLen) != totalSize {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WitnessArgs", strconv.Itoa(int64(sliceLen)), "!=", strconv.Itoa(int64(totalSize))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if uint32(sliceLen) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WitnessArgs", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
// 	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
// 		errMsg := strings.Join([]string{"OffsetsNotMatch", "WitnessArgs", strconv.Itoa(int64(offsetFirst % 4)), "!= 0", strconv.Itoa(int64(offsetFirst)), "<", strconv.Itoa(int64(HeaderSizeUint * 2))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	if sliceLen < int64(offsetFirst) {
// 		errMsg := strings.Join([]string{"HeaderIsBroken", "WitnessArgs", strconv.Itoa(int64(sliceLen)), "<", strconv.Itoa(int64(offsetFirst))}, " ")
// 		return {}, errors.New(errMsg)
// 	}

// 	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
// 	if fieldCount < 3 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	} else if !compatible && fieldCount > 3 {
// 		return {}, errors.New("FieldCountNotMatch")
// 	}

// 	offsets := make([]uint32, fieldCount)

// 	for i := 0; i < int64(fieldCount); i++ {
// 		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int64(HeaderSizeUint)*i:]))
// 	}
// 	offsets = append(offsets, uint32(totalSize))

// 	for i := 0; i < len(offsets); i++ {
// 		if i&1 != 0 && offsets[i-1] > offsets[i] {
// 			return {}, errors.New("OffsetsNotMatch")
// 		}
// 	}

// 	var err error

// 	_, err = BytesOptFromSlice(slice[offsets[0]:offsets[1]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesOptFromSlice(slice[offsets[1]:offsets[2]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	_, err = BytesOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
// 	if err.NotNone() {
// 		return {}, err
// 	}

// 	return WitnessArgs{inner: slice}, errors.None()
// }

// func (s *WitnessArgs) TotalSize() uint64 {
// 	return uint64(unpackNumber(s.inner))
// }
// func (s *WitnessArgs) FieldCount() uint64 {
// 	var number uint64 = 0
// 	if uint32(s.TotalSize()) == HeaderSizeUint {
// 		return number
// 	}
// 	number = uint64(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
// 	return number
// }
// func (s *WitnessArgs) Len() uint64 {
// 	return s.FieldCount()
// }
// func (s *WitnessArgs) IsEmpty() bool {
// 	return s.Len() == 0
// }
// func (s *WitnessArgs) CountExtraFields() uint64 {
// 	return s.FieldCount() - 3
// }

// func (s *WitnessArgs) HasExtraFields() bool {
// 	return 3 != s.FieldCount()
// }

// func (s *WitnessArgs) Lock() BytesOpt {
// 	start := unpackNumber(s.inner[4:])
// 	end := unpackNumber(s.inner[8:])
// 	return BytesOptFromSliceUnchecked(s.inner[start:end])
// }

// func (s *WitnessArgs) InputType() BytesOpt {
// 	start := unpackNumber(s.inner[8:])
// 	end := unpackNumber(s.inner[12:])
// 	return BytesOptFromSliceUnchecked(s.inner[start:end])
// }

// func (s *WitnessArgs) OutputType() BytesOpt {
// 	var ret *BytesOpt
// 	start := unpackNumber(s.inner[12:])
// 	if s.HasExtraFields() {
// 		end := unpackNumber(s.inner[16:])
// 		ret = BytesOptFromSliceUnchecked(s.inner[start:end])
// 	} else {
// 		ret = BytesOptFromSliceUnchecked(s.inner[start:])
// 	}
// 	return ret
// }

// func (s *WitnessArgs) AsBuilder() WitnessArgsBuilder {
// 	ret := NewWitnessArgsBuilder().Lock(s.Lock()).InputType(s.InputType()).OutputType(s.OutputType())
// 	return ret
// }
